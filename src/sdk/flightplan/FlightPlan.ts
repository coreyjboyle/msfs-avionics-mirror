import { AltitudeRestrictionType, FlightPlanLeg, ICAO, OneWayRunway } from '../navigation/Facilities';
import { UUID } from '../utils/uuid/UUID';
import { FlightPathCalculator } from './FlightPathCalculator';
import {
  FlightPlanSegment, FlightPlanSegmentType, LegDefinition, ProcedureDetails,
  SpeedRestrictionType, SpeedUnit, VerticalData, VerticalFlightPhase
} from './FlightPlanning';

export enum LegEventType {
  Added = 'Added',
  Removed = 'Removed',
  Changed = 'Changed',
}

export enum SegmentEventType {
  Added = 'Added',
  Removed = 'Removed',
  Changed = 'Changed',
  Inserted = 'Inserted',
}

export enum ActiveLegType {
  Lateral = 'Lateral',
  Vertical = 'Vertical',
  Calculating = 'Calculating'
}

export enum OriginDestChangeType {
  OriginAdded = 'OriginAdded',
  OriginRemoved = 'OriginRemoved',
  DestinationAdded = 'DestinationAdded',
  DestinationRemoved = 'DestinationRemoved'
}

/** Direct To Metadata for Flight Plan. */
export interface DirectToData {
  /** The segment index of the direct to target. */
  segmentIndex: number;
  /** The segment leg index of the direct to target. */
  segmentLegIndex: number;
}

/**
 * A flight plan modification batch.
 */
export type FlightPlanModBatch = {
  /** This batch's unique ID. */
  uuid: string;

  /** This batch's name. */
  name?: string;
};

/**
 * Events generated by changes in the flight plan.
 */
export interface PlanEvents {
  /**
   * A callback which is executed when a flight plan leg is added, removed, or its vertical data is changed.
   * @param segmentIndex The index of the segment containing the changed flight plan leg.
   * @param segmentLegIndex The index of the changed flight plan leg in its containing segment.
   * @param type The type of change.
   * @param leg The leg that was changed.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onLegChanged?(segmentIndex: number, segmentLegIndex: number, type: LegEventType, leg: LegDefinition, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a flight plan segment is added, removed, or changed.
   * @param index The index of the changed flight plan segment.
   * @param type The type of change.
   * @param segment The segment that was changed.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onSegmentChanged?(index: number, type: SegmentEventType, segment?: FlightPlanSegment, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when an active leg is changed.
   * @param index The global index of the leg.
   * @param segmentIndex The index of the flight plan segment.
   * @param previousSegmentIndex The index of the previously active segment.
   * @param previousLegIndex The index of the previously active leg in the previously active segment.
   * @param type The type of leg that was changed.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onActiveLegChanged?(
    index: number,
    segmentIndex: number,
    legIndex: number,
    previousSegmentIndex: number,
    previousLegIndex: number,
    type: ActiveLegType,
    batch?: readonly Readonly<FlightPlanModBatch>[]
  ): void;

  /**
   * A callback which is executed when the origin or destination changes.
   * @param type The origin/destination change type.
   * @param airport The airport that was changed.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onOriginDestChanged?(type: OriginDestChangeType, airport?: string, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when the procedure details change.
   * @param details The details that were changed.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onProcedureDetailsChanged?(details: ProcedureDetails, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a global key-value user data pair is set.
   * @param key The key of the user data.
   * @param data The user data that was set.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onUserDataSet?(key: string, data: any, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a global key-value user data pair is deleted.
   * @param key The key of the user data that was deleted.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onUserDataDelete?(key: string, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a flight plan leg key-value user data pair is set.
   * @param segmentIndex The index of the segment containing the user data's flight plan leg.
   * @param segmentLegIndex The index of the user data's flight plan leg in its containing segment.
   * @param leg The user data's flight plan leg.
   * @param key The key of the user data.
   * @param data The data that was set.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onLegUserDataSet?(segmentIndex: number, segmentLegIndex: number, leg: LegDefinition, key: string, data: any, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a flight plan leg key-value user data pair is deleted.
   * @param segmentIndex The index of the segment containing the user data's flight plan leg.
   * @param segmentLegIndex The index of the user data's flight plan leg in its containing segment.
   * @param leg The user data's flight plan leg.
   * @param key The key of the user data that was deleted.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onLegUserDataDelete?(segmentIndex: number, segmentLegIndex: number, leg: LegDefinition, key: string, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when direct to data is changed in the plan.
   * @param directToData The direct to data.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onDirectDataChanged?(directToData: DirectToData, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a flight plan vectorization begins.
   * @param index The global index of the flight plan leg that the path is to be generated from.
   * @param batch The modification batch stack to which the calculation was assigned, in order of increasing
   * nestedness. Not defined if the calculation was not assigned to any batches.
   */
  onCalculatePended?(index?: number, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a flight plan vectorization completes.
   * @param index The global index of the flight plan leg that the path was generated from.
   * @param batch The modification batch stack to which the calculation was assigned, in order of increasing
   * nestedness. Not defined if the calculation was not assigned to any batches.
   */
  onCalculated?(index?: number, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a flight plan modification batch is opened.
   * @param batch The batch that was opened.
   */
  onBatchOpened?(batch: Readonly<FlightPlanModBatch>): void;

  /**
   * A callback which is executed when a flight plan modification batch is closed.
   * @param batch The batch that was closed.
   */
  onBatchClosed?(batch: Readonly<FlightPlanModBatch>): void;

  /**
   * A callback which is executed when a flight plan modification batch has been closed and all pending asynchronous
   * operations assigned to the batch have finished.
   * @param batch The batch that was closed.
   */
  onBatchAsyncClosed?(batch: Readonly<FlightPlanModBatch>): void;
}

/**
 * An entry describing a flight plan modification batch.
 */
type FlightPlanModBatchEntry = {
  /** This entry's flight plan modification batch. */
  batch: FlightPlanModBatch;

  /** The batch's immediate parent. */
  parent: FlightPlanModBatchEntry | undefined;

  /** Whether the batch is closed. */
  isClosed: boolean;

  /** The number of lateral vectorization calculations assigned to this batch that are still pending. */
  pendingCalculateCount: number;
};

/**
 * A flight plan managed by the flight plan system.
 */
export class FlightPlan {

  private _originAirport?: string;
  // eslint-disable-next-line jsdoc/require-returns
  /** The ICAO of the origin airport in the flight plan, if any. */
  public get originAirport(): string | undefined {
    return this._originAirport;
  }

  private _destinationAirport?: string;
  // eslint-disable-next-line jsdoc/require-returns
  /** The ICAO of the destination airport in the flight plan, if any. */
  public get destinationAirport(): string | undefined {
    return this._destinationAirport;
  }

  private _activeLateralLeg = 0;
  // eslint-disable-next-line jsdoc/require-returns
  /** The global index of the currently active lateral navigation leg. */
  public get activeLateralLeg(): number {
    return this._activeLateralLeg;
  }

  private _activeVerticalLeg = 0;
  // eslint-disable-next-line jsdoc/require-returns
  /** The global index of the currently active vertical navigation leg. */
  public get activeVerticalLeg(): number {
    return this._activeVerticalLeg;
  }

  private _activeCalculatingLeg = 0;
  // eslint-disable-next-line jsdoc/require-returns
  /** The global index of the currently active calculating leg. */
  public get activeCalculatingLeg(): number {
    return this._activeCalculatingLeg;
  }

  /** The direct to metadata for this plan. */
  public readonly directToData: DirectToData = { segmentIndex: -1, segmentLegIndex: -1 };

  /**
   * Gets the current number of legs in the flight plan.
   * @returns The number of legs in the plan.
   */
  public get length(): number {
    const segment = this.planSegments[this.planSegments.length - 1];
    if (segment !== undefined) {
      return segment.offset + segment.legs.length;
    }

    return 0;
  }

  /**
   * Gets the current number of segments in the flight plan.
   * @returns The number of legs in the plan.
   */
  public get segmentCount(): number {
    return this.planSegments.length;
  }

  /** Events fired when the plan is modified. */
  public events: PlanEvents = {};

  /** The details about the selected procedures. */
  public readonly procedureDetails = new ProcedureDetails();

  /** The flight plan segments that make up this flight plan. */
  private readonly planSegments: (FlightPlanSegment | undefined)[] = [];

  /** User assignable data. */
  private readonly userData: { [index: string]: any } = {};

  private readonly batchEntryStack: FlightPlanModBatchEntry[] = [];
  private batchToCloseIndex: number | undefined = undefined;

  /**
   * Creates an instance of a FlightPlan.
   * @param planIndex The index within the flight planner of this flight plan.
   * @param calculator The flight path calculator to use to calculate the flight path.
   * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
   */
  constructor(public planIndex: number,
    public calculator: FlightPathCalculator,
    private onLegNameRequested: ((leg: FlightPlanLeg) => string | undefined)) { }

  /**
   * Gets this flight plan's legs.
   * @param reverse Whether to get the legs in reverse order. False by default.
   * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0` if `reverse` is
   * `false` or `this.length - 1` if `reverse` is `true`.
   * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length` if `reverse`
   * is `false` or `-1` if `reverse` is `true`.
   * @returns A generator which yields this flight plan's legs.
   */
  public legs(reverse = false, startIndex?: number, endIndex?: number): Generator<LegDefinition, void> {
    return reverse ? this._legsReverse(startIndex, endIndex) : this._legs(startIndex, endIndex);
  }

  /**
   * Gets this flight plan's legs in forward order.
   * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0`.
   * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length`.
   * @yields This flight plan's legs in forward order.
   */
  private *_legs(startIndex = 0, endIndex = this.length): Generator<LegDefinition, void> {
    endIndex = Math.min(this.length, endIndex);

    for (let i = 0; i < this.planSegments.length; i++) {
      const segment = this.planSegments[i];

      if (segment !== undefined && segment.legs.length > 0) {
        const end = Math.min(segment.legs.length, endIndex - segment.offset);

        if (end <= 0) {
          return;
        }

        for (let l = Math.max(0, startIndex - segment.offset); l < end; l++) {
          yield segment.legs[l];
        }
      }
    }
  }

  /**
   * Gets this flight plan's legs in reverse order.
   * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `this.length - 1`.
   * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `-1`.
   * @yields This flight plan's legs in reverse order.
   */
  private *_legsReverse(startIndex = this.length - 1, endIndex = -1): Generator<LegDefinition, void> {
    endIndex = Math.max(-1, endIndex);

    for (let i = this.planSegments.length - 1; i > -1; i--) {
      const segment = this.planSegments[i];

      if (segment !== undefined && segment.legs.length > 0) {
        const end = Math.max(-1, endIndex - segment.offset);

        if (end >= segment.legs.length) {
          return;
        }

        for (let l = Math.min(segment.legs.length - 1, startIndex - segment.offset); l > end; l--) {
          yield segment.legs[l];
        }
      }
    }
  }

  /**
   * Gets the segments for the flightplan.
   * @yields The flight plan segments.
   */
  public *segments(): Generator<FlightPlanSegment, void> {
    for (let i = 0; i < this.planSegments.length; i++) {
      const segment = this.planSegments[i];

      if (segment !== undefined) {
        yield segment;
      }
    }
  }


  /**
   * Gets all of the segments of a given type.
   * @param segmentType The type of the segments to retrieve.
   * @yields The segments of the requested type.
   */
  public *segmentsOfType(segmentType: FlightPlanSegmentType): Generator<FlightPlanSegment, void> {
    for (const segment of this.segments()) {
      if (segment.segmentType == segmentType) {
        yield segment;
      }
    }
  }

  /**
   * Gets a flight plan segment from the plan.
   * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
   * @returns The requested flight plan segment.
   * @throws An error if the flight plan segment could not be found.
   */
  public getSegment(segmentIndex?: number): FlightPlanSegment {
    const segment = this.tryGetSegment(segmentIndex);

    if (segment === null) {
      throw new Error(`Flight plan segment with ${segmentIndex === undefined ? 'active leg' : `segment index ${segmentIndex}`} could not be found.`);
    } else {
      return segment;
    }
  }

  /**
   * Attempts to get a flight plan segment from the plan.
   * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
   * @returns The requested flight plan segment, or `null` if it could not be found.
   */
  public tryGetSegment(segmentIndex?: number): FlightPlanSegment | null {
    if (segmentIndex === undefined) {
      let calculatedSegmentIndex = 0;
      for (const segment of this.segments()) {
        if (this.activeLateralLeg == 0 && segment.legs.length == 0) {
          calculatedSegmentIndex++;
        } else if (this.activeLateralLeg > segment.offset + segment.legs.length) {
          calculatedSegmentIndex++;
        } else {
          break;
        }
      }
      const segment = this.planSegments[calculatedSegmentIndex];
      if (segment !== undefined) {
        return segment;
      }
    } else if (segmentIndex >= 0) {
      const segment = this.planSegments[segmentIndex];
      if (segment !== undefined) {
        return segment;
      }
    }

    return null;
  }

  /**
   * Gets a leg from the flight plan.
   * @param segmentIndex The index of the segment containing the leg to get.
   * @param segmentLegIndex The index of the leg to get in its segment.
   * @returns A flight plan leg.
   * @throws An error if the leg could not be found.
   */
  public getLeg(segmentIndex: number, segmentLegIndex: number): LegDefinition;
  /**
   * Gets a leg from the flight plan.
   * @param globalLegIndex The global leg index of the leg to get.
   * @returns A flight plan leg.
   * @throws An error if the leg could not be found.
   */
  public getLeg(globalLegIndex: number): LegDefinition;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public getLeg(arg1: number, arg2?: number): LegDefinition {
    const leg = this._tryGetLeg(arg1, arg2);

    if (leg) {
      return leg;
    }

    throw new Error(`Leg with ${arg2 === undefined ? `index ${arg1}` : `segmentIndex ${arg1}, segmentLegIndex ${arg2}`} could not be found.`);
  }

  /**
   * Attempts to get a leg from the flight plan.
   * @param segmentIndex The index of the segment containing the leg to get.
   * @param segmentLegIndex The index of the leg to get in its segment.
   * @returns A flight plan leg, or `null` if one could not be found at the specified index.
   */
  public tryGetLeg(segmentIndex: number, segmentLegIndex: number): LegDefinition | null;
  /**
   * Attempts to get a leg from the flight plan.
   * @param globalLegIndex The global leg index of the leg to get.
   * @returns A flight plan leg, or `null` if one could not be found at the specified index.
   */
  public tryGetLeg(globalLegIndex: number): LegDefinition | null;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public tryGetLeg(arg1: number, arg2?: number): LegDefinition | null {
    return this._tryGetLeg(arg1, arg2);
  }

  /**
   * Attempts to get a leg from the flight plan.
   * @param arg1 The global leg index of the leg to get, or the index of the segment containing the leg to get.
   * @param arg2 The index of the leg to get in its segment.
   * @returns A flight plan leg, or `null` if one could not be found at the specified index.
   */
  private _tryGetLeg(arg1: number, arg2?: number): LegDefinition | null {
    if (arg2 === undefined) {
      const legIndex = arg1;
      for (const segment of this.segments()) {
        if (segment.offset <= legIndex && legIndex < segment.offset + segment.legs.length) {
          return segment.legs[legIndex - segment.offset];
        }
      }

      return null;
    } else {
      const segmentIndex = arg1;
      const segmentLegIndex = arg2;
      return this.planSegments[segmentIndex]?.legs[segmentLegIndex] ?? null;
    }
  }

  /**
   * Gets the global index of a flight plan leg in this flight plan.
   * @param leg A flight plan leg definition.
   * @returns the global index of the leg, or -1 if the leg is not in this flight plan.
   */
  public getLegIndexFromLeg(leg: LegDefinition): number {
    let index = 0;
    for (const toCompare of this.legs()) {
      if (toCompare === leg) {
        return index;
      }
      index++;
    }

    return -1;
  }

  /**
   * Gets the flight plan segment to which a leg belongs.
   * @param leg A flight plan leg definition.
   * @returns The segment to which the leg belongs, or null if the leg is not in this flight plan.
   */
  public getSegmentFromLeg(leg: LegDefinition): FlightPlanSegment | null {
    for (const segment of this.segments()) {
      if (segment.legs.includes(leg)) {
        return segment;
      }
    }

    return null;
  }

  /**
   * Gets the segment index for a given global leg index.
   * @param globalLegIndex The global leg index to get the segment index for.
   * @returns The segment index for the given global leg index, or -1 if not found.
   */
  public getSegmentIndex(globalLegIndex: number): number {
    for (const segment of this.segments()) {
      if (segment.offset <= globalLegIndex && globalLegIndex < segment.offset + segment.legs.length) {
        return segment.segmentIndex;
      }
    }
    return -1;
  }

  /**
   * Gets the segment leg index (the index of the leg in its segment) for a given global leg index.
   * @param globalLegIndex The global leg index to get the segment leg index for.
   * @returns The segment leg index, or -1 if not found.
   */
  public getSegmentLegIndex(globalLegIndex: number): number {
    const segmentIndex = this.getSegmentIndex(globalLegIndex);
    if (segmentIndex === -1) {
      return -1;
    }
    return globalLegIndex - this.getSegment(segmentIndex).offset;
  }

  /**
   * Gets the leg immediately previous to a position in this flight plan specified by segment index and leg index.
   * @param segmentIndex A segment index.
   * @param legIndex A leg index.
   * @returns the leg immediately previous to the specified position, or null if there is no such leg.
   */
  public getPrevLeg(segmentIndex: number, legIndex: number): LegDefinition | null {
    if (segmentIndex < 0) {
      return null;
    }

    segmentIndex = Math.min(segmentIndex, this.planSegments.length);
    legIndex = Math.min(legIndex, this.planSegments[segmentIndex]?.legs.length ?? 0);

    let segment = this.planSegments[segmentIndex];
    let leg = segment?.legs[legIndex - 1];
    while (!leg && --segmentIndex >= 0) {
      segment = this.planSegments[segmentIndex];
      if (segment) {
        leg = segment.legs[segment.legs.length - 1];
      }
    }

    return leg ?? null;
  }

  /**
   * Gets the leg immediately after a position in this flight plan specified by segment index and leg index.
   * @param segmentIndex A segment index.
   * @param legIndex A leg index.
   * @returns the leg immediately after the specified position, or null if there is no such leg.
   */
  public getNextLeg(segmentIndex: number, legIndex: number): LegDefinition | null {
    if (segmentIndex >= this.planSegments.length) {
      return null;
    }

    segmentIndex = Math.max(segmentIndex, -1);
    legIndex = Math.max(legIndex, -1);

    let segment = this.planSegments[segmentIndex];
    let leg = segment?.legs[legIndex + 1];
    while (!leg && ++segmentIndex < this.planSegments.length) {
      segment = this.planSegments[segmentIndex];
      if (segment) {
        leg = segment.legs[0];
      }
    }

    return leg ?? null;
  }

  /**
   * Finds a leg in this flight plan that satisfies a given condition.
   * @param predicate A function that evaluates whether each leg satisfies the condition to be returned by this method.
   * The function is called once for each evaluated leg and should return `true` if the leg satisfies the condition and
   * `false` otherwise.
   * @param reverse Whether to evaluate the legs in reverse order. Defaults to `false`.
   * @param startIndex The global leg index of the first leg to evaluate, inclusive. Defaults to `0` if `reverse` is
   * `false` or `this.length - 1` if `reverse` is `true`.
   * @param endIndex The global leg index of the last leg to evaluate, exclusive. Defaults to `this.length` if `reverse`
   * is `false` or `-1` if `reverse` is `true`.
   * @returns The first evaluated leg in this flight plan that satisfies the condition defined by the specified
   * predicate function, or `null` if no leg satisfies the condition.
   */
  public findLeg(
    predicate: (leg: LegDefinition, segment: FlightPlanSegment, segmentIndex: number, segmentLegIndex: number, plan: FlightPlan) => boolean,
    reverse = false,
    startIndex?: number,
    endIndex?: number
  ): LegDefinition | null {
    return reverse
      ? this.findLegReverse(predicate, startIndex, endIndex)
      : this.findLegForward(predicate, startIndex, endIndex);
  }

  /**
   * Evaluates legs in this flight plan in forward order and returns the first evaluated leg that satisfies a given
   * condition.
   * @param predicate A function that evaluates whether each leg satisfies the condition to be returned by this method.
   * The function is called once for each evaluated leg and should return `true` if the leg satisfies the condition and
   * `false` otherwise.
   * @param startIndex The global leg index of the first leg to evaluate, inclusive. Defaults to `0`.
   * @param endIndex The global leg index of the last leg to evaluate, exclusive. Defaults to `this.length`.
   * @returns The first evaluated leg in this flight plan that satisfies the condition defined by the specified
   * predicate function, or `null` if no leg satisfies the condition.
   */
  private findLegForward(
    predicate: (leg: LegDefinition, segment: FlightPlanSegment, segmentIndex: number, segmentLegIndex: number, plan: FlightPlan) => boolean,
    startIndex = 0,
    endIndex = this.length
  ): LegDefinition | null {
    endIndex = Math.min(this.length, endIndex);

    for (let segmentIndex = 0; segmentIndex < this.planSegments.length; segmentIndex++) {
      const segment = this.planSegments[segmentIndex];

      if (segment !== undefined && segment.legs.length > 0) {
        const end = Math.min(segment.legs.length, endIndex - segment.offset);

        if (end <= 0) {
          return null;
        }

        for (let segmentLegIndex = Math.max(0, startIndex - segment.offset); segmentLegIndex < end; segmentLegIndex++) {
          if (predicate(segment.legs[segmentLegIndex], segment, segment.segmentIndex, segmentLegIndex, this)) {
            return segment.legs[segmentLegIndex];
          }
        }
      }
    }

    return null;
  }

  /**
   * Evaluates legs in this flight plan in reverse order and returns the first evaluated leg that satisfies a given
   * condition.
   * @param predicate A function that evaluates whether each leg satisfies the condition to be returned by this method.
   * The function is called once for each evaluated leg and should return `true` if the leg satisfies the condition and
   * `false` otherwise.
   * @param startIndex The global leg index of the first leg to evaluate, inclusive. Defaults to `this.length - 1`.
   * @param endIndex The global leg index of the last leg to evaluate, exclusive. Defaults to `-1`.
   * @returns The first evaluated leg in this flight plan that satisfies the condition defined by the specified
   * predicate function, or `null` if no leg satisfies the condition.
   */
  private findLegReverse(
    predicate: (leg: LegDefinition, segment: FlightPlanSegment, segmentIndex: number, segmentLegIndex: number, plan: FlightPlan) => boolean,
    startIndex = this.length - 1,
    endIndex = -1
  ): LegDefinition | null {
    endIndex = Math.max(-1, endIndex);

    for (let segmentIndex = this.planSegments.length - 1; segmentIndex > -1; segmentIndex--) {
      const segment = this.planSegments[segmentIndex];

      if (segment !== undefined && segment.legs.length > 0) {
        const end = Math.max(-1, endIndex - segment.offset);

        if (end >= segment.legs.length) {
          return null;
        }

        for (let segmentLegIndex = Math.min(segment.legs.length - 1, startIndex - segment.offset); segmentLegIndex > end; segmentLegIndex--) {
          if (predicate(segment.legs[segmentLegIndex], segment, segment.segmentIndex, segmentLegIndex, this)) {
            return segment.legs[segmentLegIndex];
          }
        }
      }
    }

    return null;
  }

  /**
   * Gets user data from the flight plan.
   * @param key The key of the user data.
   * @returns The user data, if found.
   */
  public getUserData<T>(key: string): T | undefined {
    return this.userData[key];
  }

  /**
   * Gets the current modification batch stack.
   * @returns The current modification batch stack, or `undefined` if there are no open batches.
   */
  public getBatchStack(): readonly Readonly<FlightPlanModBatch>[] | undefined {
    return this.batchEntryStack.length > 0 ? this.batchEntryStack.map(entry => entry.batch) : undefined;
  }

  /**
   * Opens a new modification batch. The new batch will be nested within the most recently opened batch that has not
   * yet been closed. While a batch is open, all modifications made to this flight plan will be assigned to the batch.
   * The use of batches is informational only and will not affect the timing or execution of flight plan modifications.
   * All modifications are carried out immediately when the corresponding method is called regardless of whether they
   * are assigned to a batch.
   * @param name The name to assign to the new batch.
   * @returns The UUID of the new batch.
   */
  public openBatch(name?: string): string {
    const parent = this.batchEntryStack[this.batchEntryStack.length - 1] as FlightPlanModBatchEntry | undefined;

    const uuid = UUID.GenerateUuid();
    const batch = { uuid, name };
    const entry: FlightPlanModBatchEntry = {
      batch,
      parent,
      isClosed: false,
      pendingCalculateCount: 0,
    };
    this.batchEntryStack.push(entry);

    this.events.onBatchOpened && this.events.onBatchOpened(batch);

    return uuid;
  }

  /**
   * Closes a modification batch.
   * @param uuid The UUID of the batch to close. If defined, then the batch with the specified UUID and all open
   * batches that are nested within it will be closed (with the most-nested batch closed first, followed by the next
   * most-nested batch, and so on). If not defined, then the most recently opened batch that has not yet been closed
   * (i.e. the most-nested open batch) will be closed.
   */
  public closeBatch(uuid?: string): void {
    let stopIndex = this.batchEntryStack.length;

    if (uuid === undefined) {
      if (this.batchEntryStack.length > 0) {
        stopIndex = this.batchEntryStack.length - 1;
      }
    } else {
      const index = this.batchEntryStack.findIndex(entry => entry.batch.uuid === uuid);
      if (index >= 0) {
        stopIndex = index;
      }
    }

    this.closeBatchIndex(stopIndex);
  }

  /**
   * Closes all currently open modification batches.
   */
  public closeAllBatches(): void {
    this.closeBatchIndex(0);
  }

  /**
   * Closes an indexed modification batch and all batches that are nested within it.
   * @param index The index of the batch to close.
   */
  private closeBatchIndex(index: number): void {
    index = Math.max(index, 0);

    // Check if a batch closure operation is currently in progress. If one is not, then start a new batch closure
    // operation. If one is in progress, then mark the index of the new batch to close if and only if it is less-
    // nested than the in-progress operation's current batch to close.
    if (this.batchToCloseIndex === undefined) {
      this.batchToCloseIndex = index;

      while (this.batchEntryStack.length > this.batchToCloseIndex) {
        const entry = this.batchEntryStack.pop() as FlightPlanModBatchEntry;
        const currentBatchToCloseIndex: number = this.batchToCloseIndex;
        const isClosingLast = this.batchEntryStack.length === currentBatchToCloseIndex + 1;

        entry.isClosed = true;
        this.events.onBatchClosed && this.events.onBatchClosed(entry.batch);
        if (entry.pendingCalculateCount === 0) {
          this.events.onBatchAsyncClosed && this.events.onBatchAsyncClosed(entry.batch);
        }

        // If we closed the last batch and no less-nested batches were marked for closure, then we will end the
        // loop. This is to prevent us from closing any batches that were newly opened in the callbacks for closing
        // the last batch.
        if (isClosingLast && this.batchToCloseIndex === currentBatchToCloseIndex) {
          break;
        }
      }

      this.batchToCloseIndex = undefined;
    } else {
      this.batchToCloseIndex = Math.min(this.batchToCloseIndex, index);
    }
  }

  /**
   * Adds a segment to the flight plan at a specified index.
   * @param segmentIndex The index of the flight plan segment.
   * @param segmentType The type of segment this will be.
   * @param airway The airway this segment is made up of, if any.
   * @param notify Whether or not to send notifications after the operation.
   * @returns The new flight plan segment.
   */
  public addSegment(segmentIndex: number,
    segmentType: FlightPlanSegmentType = FlightPlanSegmentType.Enroute, airway?: string, notify = true): FlightPlanSegment {
    const segment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
    this.planSegments[segmentIndex] = segment;

    this.reflowSegmentOffsets();
    notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Added, segment, this.getBatchStack());

    return segment;
  }

  /**
   * Inserts a segment into the flight plan at the specified index and
   * reflows the subsequent segments.
   * @param segmentIndex The index to insert the flight plan segment.
   * @param segmentType The type of segment this will be.
   * @param airway The airway this segment is made up of, if any
   * @param notify Whether or not to send notifications after the operation.
   * @returns The new flight plan segment.
   */
  public insertSegment(segmentIndex: number,
    segmentType: FlightPlanSegmentType = FlightPlanSegmentType.Enroute, airway?: string, notify = true): FlightPlanSegment {
    const segment = this.planSegments[segmentIndex];
    if (segment !== undefined) {
      const newSegment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
      this.planSegments.splice(segmentIndex, 0, newSegment);

      this.reflowSegments();
      this.reflowSegmentOffsets();
      notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Inserted, newSegment, this.getBatchStack());

      return newSegment;
    } else {
      return this.addSegment(segmentIndex, segmentType, airway, notify);
    }
  }

  /**
   * Reflows the flight plan segments after an insert.
   */
  private reflowSegments(): void {
    for (let i = 0; i < this.planSegments.length; i++) {
      const segment = this.planSegments[i];
      if (segment !== undefined && segment.segmentIndex !== i) {
        segment.segmentIndex = i;
      }
    }
  }

  /**
   * Deletes a segment from the flight plan, leaving an empty segment at the specified index.
   * @param segmentIndex The index of the segment to remove.
   * @param notify Whether or not to send notifications after the operation.
   */
  public deleteSegment(segmentIndex: number, notify = true): void {
    const segment = this.planSegments[segmentIndex];

    if (segmentIndex === this.planSegments.length - 1) {
      this.planSegments.splice(segmentIndex, 1);
    } else {
      delete this.planSegments[segmentIndex];
    }

    if (this.directToData.segmentIndex === segmentIndex) {
      // TODO: Do we want to automatically do this?
      //this.setDirectToData(-1);
    }

    this.reflowSegmentOffsets();
    notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment, this.getBatchStack());
  }

  /**
   * Removes a segment from the flight plan and reflows the segments following
   * the removed segment, not leaving an empty segment at the specified index.
   * @param segmentIndex The index of the segment to remove.
   * @param notify Whether or not to send notifications after the operation.
   */
  public removeSegment(segmentIndex: number, notify = true): void {
    const segment = this.planSegments[segmentIndex];
    this.planSegments.splice(segmentIndex, 1);

    this.reflowSegments();
    this.reflowSegmentOffsets();
    notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment, this.getBatchStack());
  }

  /**
   * Adds a leg to the flight plan.
   * @param segmentIndex The segment to add the leg to.
   * @param leg The leg to add to the plan.
   * @param segmentLegIndex The index of the leg in the segment to insert. Will add to the end of the segment if omitted.
   * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
   * @param notify Whether or not to send notifications after the operation.
   * @returns the leg that was added.
   */
  public addLeg(segmentIndex: number, leg: FlightPlanLeg, segmentLegIndex?: number, flags = 0, notify = true): LegDefinition {
    const segment = this.getSegment(segmentIndex);
    const legDefinition: LegDefinition = {
      name: this.onLegNameRequested(leg),
      leg,
      flags,
      verticalData: {
        phase: VerticalFlightPhase.Descent,
        altDesc: AltitudeRestrictionType.Unused,
        altitude1: 0,
        altitude2: 0,
        displayAltitude1AsFlightLevel: false,
        displayAltitude2AsFlightLevel: false,
        isAltitude1TempCompensated: false,
        isAltitude2TempCompensated: false,
        speedDesc: SpeedRestrictionType.Unused,
        speed: 0,
        speedUnit: SpeedUnit.IAS,
      },
      userData: {}
    };

    if (segmentLegIndex === undefined) {
      segment.legs.push(legDefinition);
      segmentLegIndex = segment.legs.length - 1;
    } else {
      segment.legs.splice(segmentLegIndex, 0, legDefinition);
    }

    this.reflowSegmentOffsets();
    notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Added, legDefinition, this.getBatchStack());
    return legDefinition;
  }

  /**
   * Removes a leg from the flight plan.
   * @param segmentIndex The segment to add the leg to.
   * @param segmentLegIndex The index of the leg in the segment to remove. Will remove from the end of the segment if ommitted.
   * @param notify Whether or not to send notifications after the operation.
   * @returns the leg that was removed, or null if a leg was not removed.
   */
  public removeLeg(segmentIndex: number, segmentLegIndex?: number, notify = true): LegDefinition | null {
    const segment = this.getSegment(segmentIndex);

    let legDefinition: LegDefinition | undefined;

    if (segmentLegIndex === undefined) {
      legDefinition = segment.legs.pop();
      segmentLegIndex = segment.legs.length;
    } else {
      const deleted = segment.legs.splice(segmentLegIndex, 1);
      legDefinition = deleted[0] as LegDefinition | undefined;
    }

    if (this.directToData.segmentIndex === segmentIndex && this.directToData.segmentLegIndex === segmentLegIndex) {
      // TODO: Do we want to automatically do this?
      //this.setDirectToData(-1);
    }

    this.reflowSegmentOffsets();
    notify && legDefinition && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Removed, legDefinition, this.getBatchStack());
    return legDefinition ?? null;
  }

  /**
   * Reflows all flight plan segment offsets after a plan change.
   */
  private reflowSegmentOffsets(): void {
    let nextOffset: number | undefined = undefined;
    for (let i = 0; i < this.planSegments.length; i++) {
      const segment = this.planSegments[i];

      if (segment) {
        if (nextOffset === undefined) {
          segment.offset = 0;
        } else {
          segment.offset = nextOffset;
        }

        nextOffset = segment.legs.length + segment.offset;
      }
    }
  }

  /**
   * Sets the origin airport in the flight plan.
   * @param facilityIcao The origin airport to set.
   * @param notify Whether or not to send notifications after the operation.
   */
  public setOriginAirport(facilityIcao: string, notify = true): void {
    this._originAirport = facilityIcao;
    notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginAdded, facilityIcao, this.getBatchStack());
  }

  /**
   * Removes the origin airport from the flight plan.
   * @param notify Whether or not to send notifications after the operation.
   */
  public removeOriginAirport(notify = true): void {
    const facilityIcao = this._originAirport;
    this._originAirport = undefined;

    this.procedureDetails.departureIndex = -1;
    this.procedureDetails.departureRunwayIndex = -1;
    this.procedureDetails.departureTransitionIndex = -1;
    this.procedureDetails.originRunway = undefined;

    notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginRemoved, facilityIcao, this.getBatchStack());
  }

  /**
   * Sets the destination airport in the flight plan.
   * @param facilityIcao The destination airport to set.
   * @param notify Whether or not to send notifications after the operation.
   */
  public setDestinationAirport(facilityIcao: string, notify = true): void {
    this._destinationAirport = facilityIcao;
    notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationAdded, facilityIcao, this.getBatchStack());
  }

  /**
   * Removes the destination airport from the flight plan.
   * @param notify Whether or not to send notifications after the operation.
   */
  public removeDestinationAirport(notify = true): void {
    const facilityIcao = this._destinationAirport;
    this._destinationAirport = undefined;

    this.procedureDetails.approachIndex = -1;
    this.procedureDetails.approachTransitionIndex = -1;
    this.procedureDetails.arrivalIndex = -1;
    this.procedureDetails.arrivalRunwayTransitionIndex = -1;
    this.procedureDetails.arrivalRunway = undefined;
    this.procedureDetails.arrivalTransitionIndex = -1;
    this.procedureDetails.destinationRunway = undefined;

    notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationRemoved, facilityIcao, this.getBatchStack());
  }

  /**
   * Sets the active lateral leg index in the flight plan.
   * @param globalLegIndex The global leg index to set.
   * @param notify Whether or not to send notifications after the operation.
   */
  public setLateralLeg(globalLegIndex: number, notify = true): void {
    let previousLegIndex = -1;
    let previousSegmentIndex = -1;
    let segmentIndex = -1;
    let segmentLegIndex = -1;

    if (this.length > 0) {
      previousSegmentIndex = this.getSegmentIndex(this._activeLateralLeg);
      if (previousSegmentIndex > -1) {
        previousLegIndex = this._activeLateralLeg - this.getSegment(previousSegmentIndex).offset;
      }
      this._activeLateralLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
      segmentIndex = this.getSegmentIndex(this._activeLateralLeg);
      if (segmentIndex > -1) {
        segmentLegIndex = this._activeLateralLeg - this.getSegment(segmentIndex).offset;
      }
    } else {
      this._activeLateralLeg = 0;
    }

    notify
      && this.events.onActiveLegChanged
      && this.events.onActiveLegChanged(
        this._activeLateralLeg,
        segmentIndex, segmentLegIndex,
        previousSegmentIndex, previousLegIndex,
        ActiveLegType.Lateral,
        this.getBatchStack()
      );
  }

  /**
   * Sets the active lateral leg index in the flight plan.
   * @param globalLegIndex The global leg index to set.
   * @param notify Whether or not to send notifications after the operation.
   */
  public setVerticalLeg(globalLegIndex: number, notify = true): void {
    let previousLegIndex = -1;
    let previousSegmentIndex = -1;
    let segmentIndex = -1;
    let segmentLegIndex = -1;

    if (this.length > 0) {
      previousSegmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
      if (previousSegmentIndex > -1) {
        previousLegIndex = this._activeVerticalLeg - this.getSegment(previousSegmentIndex).offset;
      }
      this._activeVerticalLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
      segmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
      if (segmentIndex > -1) {
        segmentLegIndex = this._activeVerticalLeg - this.getSegment(segmentIndex).offset;
      }
    } else {
      this._activeVerticalLeg = 0;
    }

    notify
      && this.events.onActiveLegChanged
      && this.events.onActiveLegChanged(
        this._activeVerticalLeg,
        segmentIndex, segmentLegIndex,
        previousSegmentIndex, previousLegIndex,
        ActiveLegType.Vertical,
        this.getBatchStack()
      );
  }

  /**
   * Sets the active calculating leg index in the flight plan.
   * @param globalLegIndex The global leg index to set.
   * @param notify Whether or not to send notifications after the operation.
   */
  public setCalculatingLeg(globalLegIndex: number, notify = true): void {
    let previousLegIndex = -1;
    let previousSegmentIndex = -1;
    let segmentIndex = -1;
    let segmentLegIndex = -1;

    if (this.length > 0) {
      previousSegmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
      if (previousSegmentIndex > -1) {
        previousLegIndex = this._activeCalculatingLeg - this.getSegment(previousSegmentIndex).offset;
      }
      this._activeCalculatingLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
      segmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
      if (segmentIndex > -1) {
        segmentLegIndex = this._activeCalculatingLeg - this.getSegment(segmentIndex).offset;
      }
    } else {
      this._activeCalculatingLeg = 0;
    }

    notify
      && this.events.onActiveLegChanged
      && this.events.onActiveLegChanged(
        this._activeCalculatingLeg,
        segmentIndex, segmentLegIndex,
        previousSegmentIndex, previousLegIndex,
        ActiveLegType.Calculating,
        this.getBatchStack()
      );
  }

  /**
   * Sets the flight plan procedure details.
   * @param details The details of the flight plan's procedures.
   * @param notify Whether or not to send notifications after the operation.
   */
  public setProcedureDetails(details: Partial<ProcedureDetails>, notify = true): void {
    // We iterate of the keys of `details` because we need to be able to set fields to undefined
    // and we only want to overwrite fields that were in the `details` object
    for (const key of Object.keys(details)) {
      (this.procedureDetails as any)[key] = details[key as keyof ProcedureDetails];
    }

    notify && this.events.onProcedureDetailsChanged && this.events.onProcedureDetailsChanged(this.procedureDetails, this.getBatchStack());
  }

  /**
   * Sets the direct to data for this plan.
   * @param globalLegIndex The global leg index of the direct to target, or -1 if the direct to data is to be cleared.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public setDirectToData(globalLegIndex: number, notify?: boolean): void;
  /**
   * Sets the direct to data for this plan.
   * @param segmentIndex The segment index of the direct to target, or -1 if the direct to data is to be cleared.
   * @param segmentLegIndex The segment leg index of the direct to target, or -1 if the direct to data is to be
   * cleared.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public setDirectToData(segmentIndex: number, segmentLegIndex: number, notify?: boolean): void;
  /**
   * Sets the direct to data for this plan.
   * @param leg The target leg of the direct to, or null if the direct to data is to be cleared.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public setDirectToData(leg: LegDefinition | null, notify?: boolean): void;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public setDirectToData(arg1: number | LegDefinition | null, arg2?: number | boolean, arg3?: boolean): void {
    if (typeof arg1 !== 'number') {
      // arg1 is a LegDefinition or null.
      arg1 = arg1 ? this.getLegIndexFromLeg(arg1) : -1;
    }

    let segmentIndex = -1;
    let segmentLegIndex = -1;
    let notify = true;
    if (typeof arg2 !== 'number') {
      const globalLegIndex = arg1;
      if (globalLegIndex >= 0) {
        segmentIndex = this.getSegmentIndex(globalLegIndex);
        if (segmentIndex >= 0) {
          segmentLegIndex = globalLegIndex - this.getSegment(segmentIndex).offset;
        }
      }
      notify = arg2 ?? true;
    } else {
      segmentIndex = arg1;
      segmentLegIndex = arg2;
      notify = arg3 ?? true;
    }

    this.directToData.segmentIndex = segmentIndex;
    this.directToData.segmentLegIndex = segmentLegIndex;

    notify && this.events.onDirectDataChanged && this.events.onDirectDataChanged(this.directToData, this.getBatchStack());
  }

  /**
   * Sets the vertical data for this plan leg.
   * @param segmentIndex The segment index of the leg in the plan to add vertical data to.
   * @param segmentLegIndex The segment leg index of the leg in the plan to add vertical data to.
   * cleared.
   * @param verticalData The Vertical Data for this leg.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public setLegVerticalData(segmentIndex: number, segmentLegIndex: number, verticalData: Partial<VerticalData>, notify?: boolean): void;
  /**
   * Sets the vertical data for this plan leg.
   * @param globalLegIndex The global leg index in the plan for the leg to add vertical data to.
   * @param verticalData The Vertical Data for this leg.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public setLegVerticalData(globalLegIndex: number, verticalData: Partial<VerticalData>, notify?: boolean): void;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public setLegVerticalData(arg1: number, arg2: number | Partial<VerticalData>, arg3?: boolean | Partial<VerticalData>, arg4?: boolean): void {
    let notify = true;
    let segmentIndex = -1;
    let segmentLegIndex = -1;
    let verticalData: Partial<VerticalData> | undefined;

    if (typeof arg2 !== 'number') {
      segmentIndex = this.getSegmentIndex(arg1);
      const segment = this.getSegment(segmentIndex);
      segmentLegIndex = arg1 - segment.offset;
      verticalData = arg2 as Partial<VerticalData>;
      notify = arg3 !== undefined ? arg3 as boolean : notify;
    } else {
      segmentIndex = arg1;
      segmentLegIndex = arg2;
      verticalData = arg3 as Partial<VerticalData>;
      notify = arg4 !== undefined ? arg4 : notify;
    }

    const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
    if (leg) {
      Object.assign(leg.verticalData, verticalData);
      notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Changed, leg, this.getBatchStack());
    } else {
      console.warn(`Failed to set Leg Vertical Data for Segment ${segmentIndex} Leg ${segmentLegIndex}.`);
    }
  }

  /**
   * Sets the airway for a segment.
   * @param segmentIndex A segment index.
   * @param airway The airway name.
   * @param notify is whether to send an event for this change
   */
  public setAirway(segmentIndex: number, airway?: string, notify = true): void {
    const segment = this.getSegment(segmentIndex);
    if (!airway) {
      segment.airway = undefined;
    } else {
      segment.airway = airway;
    }
    this.events.onSegmentChanged && notify && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Changed, segment, this.getBatchStack());
  }

  /**
   * Sets a global key-value user data pair for this flight plan. Setting a key's user data to `undefined` will delete
   * the key instead.
   * @param key The key of the user data.
   * @param data The data to set.
   * @param notify Whether or not to notify subscribers. Defaults to true.
   */
  public setUserData<T>(key: string, data: T, notify = true): void {
    if (data === undefined) {
      this.deleteUserData(key, notify);
      return;
    }

    this.userData[key] = data;
    this.events.onUserDataSet && notify && this.events.onUserDataSet(key, data, this.getBatchStack());
  }

  /**
   * Deletes a global key-value user data pair for this flight plan.
   * @param key The key to delete.
   * @param notify Whether or not to notify subscribers.
   */
  public deleteUserData(key: string, notify = true): void {
    if (this.userData[key] !== undefined) {
      delete this.userData[key];
    }
    this.events.onUserDataDelete && notify && this.events.onUserDataDelete(key, this.getBatchStack());
  }

  /**
   * Sets a key-value user data pair for a flight plan leg. Setting a key's user data to `undefined` will delete the
   * key instead.
   * @param segmentIndex The index of the segment containing the flight plan leg for which to set the user data.
   * @param segmentLegIndex The index of the flight plan leg for which to set the user data in its containing segment.
   * @param key The key under which to set the user data.
   * @param data The user data to set under the key.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public setLegUserData<T>(segmentIndex: number, segmentLegIndex: number, key: string, data: T, notify?: boolean): void;
  /**
   * Sets a key-value user data pair for a flight plan leg. Setting a key's user data to `undefined` will delete the
   * key instead.
   * @param globalLegIndex The global index of the flight plan leg for which to set the user data.
   * @param key The key under which to set the user data.
   * @param data The user data to set under the key.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public setLegUserData<T>(globalLegIndex: number, key: string, data: T, notify?: boolean): void;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public setLegUserData(arg1: number, arg2: number | string, arg3?: any, arg4?: any, arg5?: boolean): void {
    let notify: boolean;
    let segmentIndex = -1;
    let segmentLegIndex = -1;
    let key: string;
    let data: any;

    if (typeof arg2 !== 'number') {
      segmentIndex = this.getSegmentIndex(arg1);
      const segment = this.getSegment(segmentIndex);
      segmentLegIndex = arg1 - segment.offset;
      key = arg2 as string;
      data = arg3;
      notify = arg4 === undefined ? true : arg4 as boolean;
    } else {
      segmentIndex = arg1;
      segmentLegIndex = arg2;
      key = arg3 as string;
      data = arg4;
      notify = arg5 === undefined ? true : arg5;
    }

    if (data === undefined) {
      this.deleteLegUserData(segmentIndex, segmentLegIndex, key, notify);
      return;
    }

    const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
    if (leg) {
      leg.userData[key] = data;
      notify && this.events.onLegUserDataSet && this.events.onLegUserDataSet(segmentIndex, segmentLegIndex, leg, key, data, this.getBatchStack());
    } else {
      console.warn(`FlightPlan: failed to set leg user data; leg does not exist at segment index ${segmentIndex}, segment leg index ${segmentLegIndex}.`);
    }
  }

  /**
   * Deletes a key-value user data pair for a flight plan leg.
   * @param segmentIndex The index of the segment containing the flight plan leg for which to delete the user data.
   * @param segmentLegIndex The index of the flight plan leg for which to delete the user data in its containing
   * segment.
   * @param key The key to delete.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public deleteLegUserData(segmentIndex: number, segmentLegIndex: number, key: string, notify?: boolean): void;
  /**
   * Deletes a key-value user data pair for a flight plan leg.
   * @param globalLegIndex The global index of the flight plan leg for which to delete the user data.
   * @param key The key to delete.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public deleteLegUserData(globalLegIndex: number, key: string, notify?: boolean): void;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public deleteLegUserData(arg1: number, arg2: number | string, arg3?: string | boolean, arg4?: boolean): void {
    let notify: boolean;
    let segmentIndex = -1;
    let segmentLegIndex = -1;
    let key: string;

    if (typeof arg2 !== 'number') {
      segmentIndex = this.getSegmentIndex(arg1);
      const segment = this.getSegment(segmentIndex);
      segmentLegIndex = arg1 - segment.offset;
      key = arg2 as string;
      notify = arg3 === undefined ? true : arg3 as boolean;
    } else {
      segmentIndex = arg1;
      segmentLegIndex = arg2;
      key = arg3 as string;
      notify = arg4 === undefined ? true : arg4;
    }

    const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
    if (leg) {
      delete leg.userData[key];
      notify && this.events.onLegUserDataDelete && this.events.onLegUserDataDelete(segmentIndex, segmentLegIndex, leg, key, this.getBatchStack());
    } else {
      console.warn(`FlightPlan: failed to delete leg user data; leg does not exist at segment index ${segmentIndex}, segment leg index ${segmentLegIndex}.`);
    }
  }

  /**
   * Sets the origin runway in procedure details.
   * @param runway The oneway runway to set as the origin, or undefined
   * @param notify Whether or not to notify subscribers.
   */
  public setOriginRunway(runway: OneWayRunway | undefined = undefined, notify = true): void {
    this.procedureDetails.originRunway = runway;
    const details = new ProcedureDetails;
    Object.assign(details, this.procedureDetails);

    this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
  }

  /**
   * Sets the destination runway in procedure details.
   * @param runway The oneway runway to set as the destination, or undefined
   * @param notify Whether or not to notify subscribers.
   */
  public setDestinationRunway(runway: OneWayRunway | undefined = undefined, notify = true): void {
    this.procedureDetails.destinationRunway = runway;
    const details = new ProcedureDetails;
    Object.assign(details, this.procedureDetails);

    this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
  }

  /**
   * Sets the departure procedure details.
   * @param facilityIcao The facility ICAO of the facility containing the procedure
   * @param departureIndex The index of the departure in the origin airport information
   * @param departureTransitionIndex The index of the departure transition in the origin airport departure information
   * @param departureRunwayIndex The index of the selected runway in the original airport departure information
   * @param notify Whether or not to notify subscribers.
   */
  public setDeparture(facilityIcao: string | undefined = undefined, departureIndex = -1, departureTransitionIndex = -1, departureRunwayIndex = -1, notify = true): void {
    this.procedureDetails.departureIndex = departureIndex;
    this.procedureDetails.departureFacilityIcao = facilityIcao;
    this.procedureDetails.departureTransitionIndex = departureTransitionIndex;
    this.procedureDetails.departureRunwayIndex = departureRunwayIndex;
    const details = new ProcedureDetails;
    Object.assign(details, this.procedureDetails);

    this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
  }

  /**
   * Sets the arrival procedure details.
   * @param facilityIcao The facility ICAO of the facility containing the procedure
   * @param arrivalIndex The index of the arrival in the destination airport information
   * @param arrivalTransitionIndex index of the arrival transition in the destination airport arrival information
   * @param arrivalRunwayTransitionIndex The index of the selected runway transition at the destination airport arrival information
   * @param arrivalRunway The oneway runway to set as the arrival runway, or undefined
   * @param notify Whether or not to notify subscribers
   */
  public setArrival(
    facilityIcao: string | undefined = undefined, arrivalIndex = -1, arrivalTransitionIndex = -1,
    arrivalRunwayTransitionIndex = -1, arrivalRunway: OneWayRunway | undefined = undefined, notify = true,
  ): void {
    this.procedureDetails.arrivalIndex = arrivalIndex;
    this.procedureDetails.arrivalFacilityIcao = facilityIcao;
    this.procedureDetails.arrivalTransitionIndex = arrivalTransitionIndex;
    this.procedureDetails.arrivalRunwayTransitionIndex = arrivalRunwayTransitionIndex;
    this.procedureDetails.arrivalRunway = arrivalRunway;
    const details = new ProcedureDetails;
    Object.assign(details, this.procedureDetails);

    this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
  }

  /**
   * Sets the approach procedure details.
   * @param facilityIcao The facility ICAO of the facility containing the procedure
   * @param approachIndex The index of the apporach in the destination airport information
   * @param approachTransitionIndex The index of the approach transition in the destination airport approach information
   * @param notify Whether or not to notify subscribers
   */
  public setApproach(facilityIcao: string | undefined = undefined, approachIndex = -1, approachTransitionIndex = -1, notify = true): void {
    this.procedureDetails.approachIndex = approachIndex;
    this.procedureDetails.approachFacilityIcao = facilityIcao;
    this.procedureDetails.approachIndex = approachIndex;
    this.procedureDetails.approachTransitionIndex = approachTransitionIndex;
    const details = new ProcedureDetails;
    Object.assign(details, this.procedureDetails);

    this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
  }

  /**
   * Calculates the flight path for the plan.
   * @param globalLegIndex The global leg index to start calculating from.
   * @param notify Whether or not to send notifications after the operation.
   */
  public async calculate(globalLegIndex?: number, notify = true): Promise<void> {
    const batchStack = this.getBatchStack();
    const batchEntry = this.batchEntryStack[this.batchEntryStack.length - 1] as FlightPlanModBatchEntry | undefined;

    let currentBatchEntry = batchEntry;
    while (currentBatchEntry) {
      currentBatchEntry.pendingCalculateCount++;
      currentBatchEntry = currentBatchEntry.parent;
    }

    notify && this.events.onCalculatePended && this.events.onCalculatePended(globalLegIndex, batchStack);

    const legs = [...this.legs()];
    await this.calculator.calculateFlightPath(legs, this.activeLateralLeg, globalLegIndex === undefined ? this.activeCalculatingLeg : globalLegIndex);

    notify && this.events.onCalculated && this.events.onCalculated(globalLegIndex, batchStack);

    currentBatchEntry = batchEntry;
    while (currentBatchEntry) {
      currentBatchEntry.pendingCalculateCount--;
      if (currentBatchEntry.isClosed && currentBatchEntry.pendingCalculateCount === 0) {
        this.events.onBatchAsyncClosed && this.events.onBatchAsyncClosed(currentBatchEntry.batch);
      }
      currentBatchEntry = currentBatchEntry.parent;
    }
  }

  /**
   * Copies the flight plan.
   * @param planIndex The flight plan index to assign to this plan, or the same plan
   * index if not provided.
   * @param copyCalcs Whether to copy leg calculations (defaults to false).
   * @returns The copied flight plan.
   */
  public copy(planIndex?: number, copyCalcs = false): FlightPlan {
    if (planIndex === undefined) {
      planIndex = this.planIndex;
    }
    const newPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);

    newPlan.copyFrom(this, copyCalcs);

    return newPlan;
  }

  /**
   * Copies a source flight plan into this one, overriding everything in this plan with everything from the source plan.
   * @param sourcePlan The plan to copy from.
   * @param copyCalcs Whether to copy leg calculations (defaults to false).
   */
  public copyFrom(sourcePlan: FlightPlan, copyCalcs = false): void {

    if (sourcePlan._originAirport !== undefined) {
      this.setOriginAirport(sourcePlan._originAirport, false);
    } else {
      this.removeOriginAirport(false);
    }

    if (sourcePlan._destinationAirport !== undefined) {
      this.setDestinationAirport(sourcePlan._destinationAirport, false);
    } else {
      this.removeDestinationAirport(false);
    }

    // We do object assign against new proc details in case the incoming details are missing fields because of coming from json
    // and because we want to overwrite the entire object, instead of just some fields.
    this.setProcedureDetails(Object.assign(new ProcedureDetails(), sourcePlan.procedureDetails), false);

    const targetPlanSegmentsCount = this.planSegments.length;
    for (let i = 0; i < targetPlanSegmentsCount; i++) {
      this.removeSegment(0, false);
    }

    for (let i = 0; i < sourcePlan.planSegments.length; i++) {
      const segment = sourcePlan.planSegments[i];

      if (segment !== undefined) {
        this.addSegment(segment.segmentIndex, segment.segmentType, segment.airway, false);
        for (const leg of segment.legs) {
          const newLeg = this.addLeg(segment.segmentIndex, leg.leg, undefined, leg.flags, false);
          const legIndex = this.getLegIndexFromLeg(newLeg);
          this.setLegVerticalData(legIndex, leg.verticalData, false);

          for (const key in leg.userData) {
            this.setLegUserData(legIndex, key, leg.userData[key], false);
          }

          copyCalcs && FlightPlan.copyLegCalculations(leg, newLeg);
        }
      }
    }

    this.setDirectToData(sourcePlan.directToData.segmentIndex, sourcePlan.directToData.segmentLegIndex, false);

    // Have to copy from the private fields, because the public ones are getters, which would be lost when stringified
    this.setLateralLeg(sourcePlan._activeLateralLeg, false);
    this.setVerticalLeg(sourcePlan._activeVerticalLeg, false);
    this.setCalculatingLeg(sourcePlan._activeCalculatingLeg, false);

    for (const key in this.userData) {
      this.deleteUserData(key, false);
    }

    for (const key in sourcePlan.userData) {
      this.setUserData(key, sourcePlan.userData[key], false);
    }
  }

  /**
   * Copies leg calcs from an existing leg to a new leg.
   * @param existingLeg The leg that we want to copy the calcs from.
   * @param newLeg The leg that we want to copy the calcs to.
   * @returns the newLeg with the copied calcs.
   */
  private static copyLegCalculations(existingLeg: LegDefinition, newLeg: LegDefinition): LegDefinition {
    if (existingLeg.calculated !== undefined) {
      newLeg.calculated = {
        courseMagVar: existingLeg.calculated.courseMagVar,
        initialDtk: existingLeg.calculated.initialDtk,
        distance: existingLeg.calculated.distance,
        cumulativeDistance: existingLeg.calculated.cumulativeDistance,
        distanceWithTransitions: existingLeg.calculated.distanceWithTransitions,
        cumulativeDistanceWithTransitions: existingLeg.calculated.cumulativeDistanceWithTransitions,
        startLat: existingLeg.calculated.startLat,
        startLon: existingLeg.calculated.startLon,
        endLat: existingLeg.calculated.endLat,
        endLon: existingLeg.calculated.endLon,
        flightPath: existingLeg.calculated.flightPath.map(vector => Object.assign({}, vector)),
        ingress: existingLeg.calculated.ingress.map(vector => Object.assign({}, vector)),
        ingressJoinIndex: existingLeg.calculated.ingressJoinIndex,
        ingressToEgress: existingLeg.calculated.ingressToEgress.map(vector => Object.assign({}, vector)),
        egressJoinIndex: existingLeg.calculated.egressJoinIndex,
        egress: existingLeg.calculated.egress.map(vector => Object.assign({}, vector)),
        endsInFallback: existingLeg.calculated.endsInFallback
      };
    }
    return newLeg;
  }

  /**
   * Creates a default instance of a flight plan leg.
   * @param partial A portion of leg options to apply.
   * @returns A default instance of a flight plan leg.
   */
  public static createLeg = (partial: Partial<FlightPlanLeg>): FlightPlanLeg => Object.assign({
    type: 0,
    fixIcao: ICAO.emptyIcao,
    arcCenterFixIcao: ICAO.emptyIcao,
    originIcao: ICAO.emptyIcao,
    flyOver: 0,
    turnDirection: 0,
    trueDegrees: 0,
    theta: 0,
    rho: 0,
    distance: 0,
    distanceMinutes: 0,
    speedRestriction: 0,
    altDesc: 0,
    altitude1: 0,
    altitude2: 0,
    course: 0,
    fixTypeFlags: 0,
    verticalAngle: 0,
  }, partial);
}
